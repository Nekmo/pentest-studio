import { Injectable } from '@angular/core';
import {ActivatedRoute} from "@angular/router";
import {catchError} from "rxjs/internal/operators";
import {HttpClient} from "@angular/common/http";
import {Observable, Subject} from "rxjs";
import {MatSnackBar} from "@angular/material/snack-bar";
import { EMPTY } from 'rxjs'



@Injectable({
    providedIn: 'root'
})
export class StorageService {

    url: any;
    storageProjectKey: string|null = null;
    _item: any = null;
    change: Subject<any> = new Subject();

    constructor(
        public route: ActivatedRoute,
        public snackBar: MatSnackBar,
        public http: HttpClient,
    ) {}

    _setItem(item: any) {
        this._item = item;
        if(item) {
            localStorage.setItem(this.storageProjectKey as string, item.pk.toString());
        } else {
            localStorage.removeItem(this.storageProjectKey as string);
        }
        this.change.next(item);
    }

    setItem(item: any) {
        if(typeof item === 'number') {
            this.http.get(`${this.url}${item}/`)
                .pipe(catchError((err: any, caught: Observable<any>) => {
                    this.catchHttpError(err, caught);
                    return EMPTY;
                }))
                .subscribe((custom) => {
                this._setItem(custom);
            });
        } else {
            this._setItem(item);
        }
    }

    catchHttpError(err: any, caught: any) {
        this.snackBar.open('Error on storage: ' + JSON.stringify(err.error),
            'Close', {
            duration: 15000,
        });
        return EMPTY;
    }

    getItem() {
        return Observable.create((observer: any) => {
            // https://github.com/angular/angular/issues/11023
            let itemId = localStorage.getItem(this.storageProjectKey as string);
            if(itemId && (!this._item || this._item.id != parseInt(itemId))) {
                this.http.get(`${this.url}${itemId}/`)
                    .pipe(catchError((err: any, caught: Observable<any>) => {
                        this.catchHttpError(err, caught);
                        return EMPTY;
                    }))
                    .subscribe((project) => {
                    this.setItem(project);
                    observer.next(project);
                });
            } else if(!itemId) {
                observer.next(null);
            } else {
                observer.next(this._item);
            }
        });
    }
}


@Injectable({
    providedIn: 'root'
})
export class SelectProjectService extends StorageService {
    storageProjectKey: string = 'projectId';
    url: string = '/api/projects/projects/';

    constructor(
        route: ActivatedRoute,
        snackBar: MatSnackBar,
        public http: HttpClient,
    ) {
        super(route, snackBar, http);
    }

}
