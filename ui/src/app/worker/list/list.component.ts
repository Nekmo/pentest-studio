import {Component, OnDestroy, OnInit, Pipe, PipeTransform, ViewChild} from '@angular/core';
import {MatTree} from "@angular/material/tree";
import {ActionApi, Worker, WorkerApi} from "../../shared/api.service";
import {finalize} from "rxjs/operators";
import {WorkerMessageEvent, WorkerWebSocket} from "../../shared/ws.service";


const MIN_UPDATED_AT = 1000 * 10;


@Pipe({
    name: 'minUpdatedAtFilter',
    pure: true
})
export class MinUpdatedAtPipe implements PipeTransform {
    transform(items: any[], minDate: Date): any {
        if (!items || !minDate) {
            return items;
        }
        // filter items array, items which match and return true will be
        // kept, false will be filtered out
        return items.filter(item => item.value.updatedAt > minDate);
    }
}


@Component({
    selector: 'app-list',
    templateUrl: './list.component.html',
    styleUrls: ['./list.component.scss']
})
export class ListComponent implements OnInit, OnDestroy {

    workerMetrics: {[metricName: string]: any} = {};
    terminalMetrics: {[workerId: string]: {[actionId: string]: {[metricName: string]: any}}} = {};

    workers: Worker[] = [];
    minUpdatedAt: Date|null = null;
    destroyed: boolean = false;

    @ViewChild('tree') matTree: MatTree<any>;

    constructor(private workerApi: WorkerApi,
                private actionApi: ActionApi,
                private workerWebSocket: WorkerWebSocket) {
    }

    ngOnInit(): void {
        const workers: Worker[] = [];
        // this.dataSource.data = [];

        this.workerApi.all()
            .pipe(finalize(() => {
                // this.dataSource.data = workers;
                this.workers = workers;
            }))
            .subscribe((el) => {
                console.log(el);
                workers.push(el);
            });
        this.workerWebSocket.start()
        this.workerWebSocket.metricSubscribe('worker_machine', (event: WorkerMessageEvent) => {
            if (event.message.metric_data.sensors_temperatures.coretemp) {
                const sum = event.message.metric_data.sensors_temperatures.coretemp
                    .map((x: {current: number}) => x.current)
                    .reduce((a: number, b: number) => a + b, 0);
                const avg: number = (sum / event.message.metric_data.sensors_temperatures.coretemp.length) || 0;
                console.log(sum);
                event.message.metric_data.sensors_temperatures.coretemp_avg = avg;
            }
            this.workerMetrics[event.worker_id] = event;
        });
        this.workerWebSocket.metricSubscribe('terminal', (event: WorkerMessageEvent) => {
            let metrics = this.terminalMetrics[event.worker_id];
            if (metrics === undefined) {
                metrics = {};
                this.terminalMetrics[event.worker_id] = metrics;
            }
            event.message.updatedAt = new Date();
            metrics[event.message.terminal_name] = event.message;
            // this.matTree.renderNodeChanges(this.dataSource.data);
        });
        this.updateMinUpdatedAt();
    }

    updateMinUpdatedAt() {
        if (this.destroyed) {
            return;
        }
        this.minUpdatedAt = new Date(new Date().getTime() - MIN_UPDATED_AT);
        setTimeout(() => this.updateMinUpdatedAt(), 5);
    }

    ngOnDestroy() {
        this.destroyed = true;
        this.workerWebSocket.close();
    }

}
