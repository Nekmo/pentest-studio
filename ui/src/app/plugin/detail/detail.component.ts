import {ChangeDetectorRef, Component, OnDestroy, OnInit} from '@angular/core';
import {MediaMatcher} from "@angular/cdk/layout";
import {ActivatedRoute, Router} from "@angular/router";
import {PluginApi, PluginCollectionApi} from "../../shared/api.service";
import {FormControl, FormGroup} from "@angular/forms";
import {FormlyFieldConfig} from "@ngx-formly/core";
import {catchError} from "rxjs/internal/operators";
import {EMPTY} from "rxjs";


export type errorResponse = {[fieldName: string]: string[]|errorResponse[]|errorResponse};


function errorResponseToMessage(error: errorResponse, prefix: string = '') {
    const errorMessages: string[] = [];
    Object.entries(error).map((items) => {
        const key: string = items[0];
        const value: string[]|errorResponse[]|errorResponse = items[1];
        if (Array.isArray(value) && value.length && typeof value[0] === 'string') {
            errorMessages.push(`${prefix}${key}: ${value.join(", ")}`);
        } else if (typeof value === 'object' && !Array.isArray(value)) {
            const errors = errorResponseToMessage(value as errorResponse, `${key}->`);
            Array.prototype.push.apply(errorMessages, errors);
            // const errors: string[] = Object.entries(value as {[fieldName: string]: errorResponse})
            //     .map((keyValue: [string, errorResponse]) => {
            //         return errorResponseToMessage(keyValue[1], `${keyValue[0]}->`).join(', ');
            //     })
            // Array.prototype.push.apply(errorMessages, errors);
        } else {
            const errors: string[] = (value as errorResponse[]).map((valueItem: errorResponse) => {
                return errorResponseToMessage(valueItem, `${key}->`).join(', ');
            })
            Array.prototype.push.apply(errorMessages, errors);
        }
    });
    return errorMessages;
}


@Component({
    selector: 'app-detail',
    templateUrl: './detail.component.html',
    styleUrls: ['./detail.component.scss']
})
export class DetailComponent implements OnInit, OnDestroy {

    mobileQuery: MediaQueryList;
    private _mobileQueryListener: () => void;
    content: string = '';
    file: string = '';
    type: 'plugin'|'pluginCollection'|null = null;
    errorMessage: string[] = [];
    model = {};

    form = new FormGroup({
        fileId: new FormControl(''),
    });

    constructor(private route: ActivatedRoute,
                changeDetectorRef: ChangeDetectorRef,
                media: MediaMatcher,
                private pluginApi: PluginApi,
                private pluginCollectionApi: PluginCollectionApi,
                private router: Router) {
        this.mobileQuery = media.matchMedia('(max-width: 600px)');
        this._mobileQueryListener = () => changeDetectorRef.detectChanges();
        this.mobileQuery.addListener(this._mobileQueryListener);
    }

    ngOnInit(): void {
        this.route.params.subscribe(() => {
            this.updateRouteId();
        });
        this.updateRouteId();
    }

    getQuerySet() {
        if (this.type === 'plugin') {
            return this.pluginApi;
        } else if(this.type === 'pluginCollection') {
            return this.pluginCollectionApi;
        } else {
            throw Error(`Invalid type: ${this.type}`);
        }
    }

    updateRouteId() {
        const fileId: string = this.route.snapshot.paramMap.get('fileId') as string;
        if (!fileId) {
            return;
        }
        const parts: string[] = fileId.split('.', 2);
        if (parts[1] === 'collection') {
            this.type = 'pluginCollection';
        } else if (parts[1] == 'plugin') {
            this.type = 'plugin';
        } else {
            throw Error(`Invalid type: ${parts[1]}`);
        }
        this.file = parts[0];
        this.form.controls.fileId.patchValue(this.file);
        this.updateContent();
    }

    updateContent() {
        this.getQuerySet().getText(this.file).subscribe((content: string) => {
            this.content = content;
        });
    }

    ngOnDestroy() {
    }

    submit(model): void {
        this.errorMessage = [];
        let newFileName: string = '';
        const formFileName: string = this.form.controls.fileId.value;
        if (this.file !== formFileName) {
            const type: string = (this.type === 'pluginCollection' ? 'collection' : this.type as string);
            newFileName = `${formFileName}.${type}`;
        }
        this.getQuerySet()
            .update(this.file, this.content as unknown as any, newFileName)
            .pipe(catchError((err) => {
                this.errorMessage = errorResponseToMessage(err.error);
                return EMPTY;
            }))
            .subscribe(() => {
            if (newFileName) {
                this.file = newFileName;
                this.router.navigate([`/plugins/${newFileName}`])
            }
        });
    }

}
