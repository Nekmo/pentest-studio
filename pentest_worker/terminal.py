"""One shared terminal per URL endpoint
Plus a /new URL which will create a new terminal and redirect to it.
"""
from __future__ import print_function, absolute_import

import json
import os.path
import threading
import time
from collections import deque

import psutil as psutil
import tornado.ioloop
import terminado

import tornado.web
# This demo requires tornado_xstatic and XStatic-term.js
# import tornado_xstatic
from django.conf import settings
from ptyprocess import PtyProcessUnicode

from terminado import TermSocket, NamedTermManager
from terminado.management import MaxTerminalsReached, PtyWithClients

from pentest_worker.connections import upload_worker_data, get_action
from pentest_worker.log import create_logger
from pentest_worker.rsa import decrypt

STATIC_DIR = os.path.join(os.path.dirname(terminado.__file__), "_static")
TEMPLATE_DIR = os.path.join(os.path.dirname(__file__))
MAX_LENGTH_BUFFER = 40
MAX_CHILDREN_RETRIES = 100


logger = create_logger(__name__)


AUTH_TYPES = ("none", "login")

START_COMMANDS = """
command -v asciinema > /dev/null || pip install asciinema
asciinema rec -i 2.5 asciinema.cast
"""


def get_ip(request):
    x_real_ip = request.headers.get("X-Real-IP")
    return x_real_ip or request.remote_ip


class ChildrenProcessShutdown(threading.Thread):
    def __init__(self, on_shutdown, process, children_count=3, **kwargs):
        self.on_shutdown = on_shutdown
        self.process = process
        self.children_count = children_count
        super().__init__(**kwargs)
        self.daemon = True

    def run(self):
        for i in range(MAX_CHILDREN_RETRIES):
            children = psutil.Process(self.process).children(recursive=True)
            if len(children) < self.children_count:
                time.sleep(.1)
                continue
            logger.info('waiting for {}'.format(children[-1]))
            children[-1].wait()
            logger.info('Finished {}'.format(children[-1]))
        self.on_shutdown()


class TerminalPtyWithClients(PtyWithClients):
    def __init__(self, argv, env=None, cwd=None):
        super().__init__(argv, env=env or [], cwd=cwd)
        self.read_buffer = deque([], maxlen=MAX_LENGTH_BUFFER)


class TerminalPageHandler(tornado.web.RequestHandler):
    """Render the /ttyX pages"""
    def get(self, term_name):
        return self.render("termpage.html", static=self.static_url,
                           xstatic=self.application.settings['xstatic_url'],
                           ws_url_path="/_websocket/"+term_name)

    def set_default_headers(self):
        self.set_header("Access-Control-Allow-Origin", "*")
        self.set_header("Access-Control-Allow-Headers", "x-requested-with")
        self.set_header('Access-Control-Allow-Methods', 'POST, GET, OPTIONS')


class NewTerminalHandler(tornado.web.RequestHandler):
    """Redirect to an unused terminal name"""
    def get(self):
        name, terminal = self.application.settings['term_manager'].new_named_terminal()
        self.redirect("/" + name, permanent=False)


class TermManager(NamedTermManager):
    def new_terminal(self, **kwargs):
        """Make a new terminal, return a :class:`PtyWithClients` instance."""
        options = self.term_settings.copy()
        options['shell_command'] = self.shell_command or ['bash']
        options.update(kwargs)
        argv = kwargs.pop('shell_command', None) or options['shell_command']
        env = self.make_term_env(**options)
        return TerminalPtyWithClients(argv, env=env, cwd=options.get('cwd', None))

    def get_terminal_directory(self, term_name):
        return os.path.join(settings.WORKER_ACTIONS_TEMP_DIRECTORY, term_name)

    def new_terminal_directory(self, term_name):
        directory = self.get_terminal_directory(term_name)
        os.makedirs(directory, exist_ok=True)
        return directory

    def execute_command(self, term_name, command):
        if not command.endswith('\n'):
            command += '\n'
        self.get_terminal(term_name).ptyproc.write(command)

    def initial_commands(self, term_name):
        self.execute_command(term_name, START_COMMANDS)

    def get_terminal(self, term_name, shell_command=None, command='bash'):
        assert term_name is not None

        if term_name in self.terminals:
            return self.terminals[term_name]

        if self.max_terminals and len(self.terminals) >= self.max_terminals:
            raise MaxTerminalsReached(self.max_terminals)

        # Create new terminal
        self.log.info("New terminal with specified name: %s", term_name)
        directory = self.new_terminal_directory(term_name)
        term = self.new_terminal(shell_command=shell_command or ['bash'], cwd=directory)
        term.term_name = term_name
        self.terminals[term_name] = term
        self.start_reading(term)
        self.initial_commands(term_name)
        if command is not None:
            self.execute_command(term_name, command)
        # Run initial action command
        action_data: dict = get_action(term_name)
        action_command = action_data.get('command')
        if action_command:
            self.execute_command(term_name, action_command)
        return term

    def on_terminal_end(self, term_name):
        logger.info('Finished term {}'.format(term_name))
        upload_worker_data(term_name)

    def start_reading(self, ptywclients):
        pid = ptywclients.ptyproc.pid
        ChildrenProcessShutdown(lambda: self.on_terminal_end(ptywclients.term_name), pid).start()
        return super().start_reading(ptywclients)


class CustomTermSocket(TermSocket):
    def __init__(self, application, request, **kwargs):
        super().__init__(application, request, **kwargs)
        self.authenticated = False
        self.url_component = None

    def open(self, url_component=None):
        self.url_component = url_component or self.url_component
        if self.authenticated:
            return super().open(self.url_component)
        else:
            self.send_json_message(["authentication-required", ""])

    def check_origin(self, origin):
        return True

    def authenticate(self, command):
        msg_type = command[0]
        if msg_type != 'authenticate':
            self.send_json_message(["authentication-required", ""])
            return
        try:
            data = decrypt(settings.PENTEST_STUDIO_PUBLIC_KEY, command[1], src_ip=get_ip(self.request))
        except ValueError:
            data = {}
        if data and data.get('action') and data['action'] == self.action_num():
            self.send_json_message(["authenticated", ""])
            self.authenticated = True
            self.open()
        else:
            self.send_json_message(["invalid-authentication", ""])

    def action_num(self):
        last = self.request.uri.split('/')[-1]
        return int(last) if last.isdigit() else last

    def on_message(self, message):
        if not self.authenticated:
            self.authenticate(json.loads(message))
            return
        return super().on_message(message)

    def write_message(self, message, binary=False):
        return super().write_message(message, binary=binary)

    def on_pty_died(self):
        return super().on_pty_died()


def start_terminal_webserver(address: str = 'localhost', port: int = 8700):
    term_manager = TermManager(shell_command=['bash'], max_terminals=100)
    # Iniciar sin necesidad de acceder
    # term_manager.get_terminal('ping', ['ping', 'google.com'])

    handlers = [
                (r"/_websocket/(\w+)", CustomTermSocket, {'term_manager': term_manager}),
                (r"/new/?", NewTerminalHandler),
                (r"/(\w+)/?", TerminalPageHandler),
                # (r"/xstatic/(.*)", tornado_xstatic.XStaticFileHandler)
               ]
    application = tornado.web.Application(
        handlers, static_path=STATIC_DIR,
        template_path=TEMPLATE_DIR,
        # xstatic_url=tornado_xstatic.url_maker('/xstatic/'),
        term_manager=term_manager
    )

    application.listen(port, address)
    loop = tornado.ioloop.IOLoop.instance()
    return loop, term_manager
    # loop.start()
    # asyncio.set_event_loop(loop)
    # try:
    #     loop.start()
    # except KeyboardInterrupt:
    #     print(" Shutting down on SIGINT")
    # finally:
    #     term_manager.shutdown()
    #     loop.close()


if __name__ == "__main__":
    start_terminal_webserver()[0].start()
