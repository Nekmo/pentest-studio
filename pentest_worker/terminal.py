"""One shared terminal per URL endpoint
Plus a /new URL which will create a new terminal and redirect to it.
"""
from __future__ import print_function, absolute_import

import json
import logging
import os.path
import subprocess
import threading
import time
from collections import deque
from dataclasses import dataclass
from typing import List, Union

import psutil as psutil
import tornado.ioloop

import tornado.web
import tornado.websocket

from django.conf import settings
from psutil import NoSuchProcess

from terminado import TermSocket, NamedTermManager
from terminado.management import MaxTerminalsReached, PtyWithClients

from pentest_worker.connections import upload_worker_data, get_action, get_all_plugins
from pentest_worker.rsa import decrypt

MAX_LENGTH_BUFFER = 40
MAX_CHILDREN_RETRIES = 100
MONITOR_MAX_LENGTH = 100
ASCIINEMA_RECORD_FILE = 'asciinema.cast'
ASCIINEMA_COMMAND = ['asciinema', 'rec', '-i', '2.5', ASCIINEMA_RECORD_FILE]

logger = logging.getLogger(__name__)
monitor_deque = deque()

AUTH_TYPES = ("none", "login")


def get_ip(request):
    x_real_ip = request.headers.get("X-Real-IP")
    return x_real_ip or request.remote_ip


def get_children_count(pid):
    try:
        return len(psutil.Process(pid).children())
    except NoSuchProcess:
        return 0


def wait_for_child_command(pid: int, name: str = ''):
    parent_process = psutil.Process(pid)
    for i in range(50):
        children = iter(parent_process.children(recursive=True))
        if name:
            children = filter(lambda x: x.name() == name, children)
        process = next(children, None)
        if process is not None:
            return process.pid
        time.sleep(.1)
    logger.error(f'Timeout waiting for {psutil.Process(parent_process.pid)}')


@dataclass()
class PluginSetup:
    test: str
    install: str


@dataclass()
class Plugin:
    id: str
    name: str
    description: str
    setup: Union[PluginSetup, dict]
    shortcuts: List

    def __post_init__(self):
        self.setup = PluginSetup(**self.setup)

    def is_installed(self) -> bool:
        try:
            subprocess.check_call(self.setup.test, shell=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        except subprocess.CalledProcessError:
            return False
        else:
            return True

    def install_plugin(self):
        return subprocess.check_call(self.setup.install, shell=True)


class Plugins:
    def __iter__(self):
        return map(lambda x: Plugin(**x), get_all_plugins())

    def install_all(self):
        for plugin in self:
            if plugin.is_installed():
                logger.info(f'Plugin {plugin.name} already installed.')
                continue
            try:
                plugin.install_plugin()
            except subprocess.CalledProcessError as e:
                logger.warning(f'Error installing plugin {plugin.name}: {e}')
            else:
                logger.info(f'Plugin {plugin.name} successfully installed.')


class RunTerminalCommand(threading.Thread):
    def __init__(self, action_command: str, term, **kwargs):
        self.action_command = action_command
        self.term = term
        self.term_name = term.term_name
        self.term_pid = term.ptyproc.pid
        self.process = psutil.Process(term.ptyproc.pid)
        super().__init__(**kwargs)
        self.daemon = True

    def execute_command(self, command):
        if not command.endswith('\n'):
            command += '\n'
        self.term.ptyproc.write(command)

    def run(self):
        try:
            bash_pid = wait_for_child_command(self.process.pid, 'bash')  # Get child bash pid
        except NoSuchProcess:
            return
        logger.info(f'Obtained bash pid {bash_pid} for terminal {self.term_pid}')
        self.execute_command(self.action_command)  # Run action_command
        logger.info(f'Waiting for a child of bash for terminal {self.term_pid}')
        wait_for_child_command(bash_pid)  # Wait for action_command started
        time.sleep(1)
        # Wait for all the children of bash
        logger.info(f'Bash already has children. Waiting for them to finish in terminal {self.term_pid}')
        while children := psutil.Process(bash_pid).children():
            child = children[0]
            logger.info('Waiting for {}'.format(child))
            child.wait()
        logger.info(f'Finishing terminal {self.term}')
        self.on_shutdown()

    def on_shutdown(self):
        logger.info('Finished term {}'.format(self.term_name))
        self.execute_command('echo "[Pentest Studio] Return code: $?"')
        time.sleep(2)
        try:
            psutil.Process(self.term_pid).terminate()
        except psutil.NoSuchProcess:
            logger.warning(f'The process {self.term_pid} could not be terminated. The process does not exist.')
        upload_worker_data(self.term_name)


class TerminalPtyWithClients(PtyWithClients):
    def __init__(self, argv, env=None, cwd=None):
        super().__init__(argv, env=env or [], cwd=cwd)
        self.read_buffer = deque([], maxlen=MAX_LENGTH_BUFFER)


class TermManager(NamedTermManager):
    def __init__(self, **kwargs):
        super().__init__(**kwargs)

    def new_terminal(self, **kwargs):
        """Make a new terminal, return a :class:`PtyWithClients` instance."""
        options = self.term_settings.copy()
        options['shell_command'] = self.shell_command
        options.update(kwargs)
        argv = kwargs.pop('shell_command', None) or options['shell_command']
        env = self.make_term_env(**options)
        return TerminalPtyWithClients(argv, env=env, cwd=options.get('cwd', None))

    def get_terminal_directory(self, term_name):
        return os.path.join(settings.WORKER_ACTIONS_TEMP_DIRECTORY, term_name)

    def new_terminal_directory(self, term_name):
        directory = self.get_terminal_directory(term_name)
        os.makedirs(directory, exist_ok=True)
        return directory

    def get_terminal(self, term_name, shell_command=None, command='bash'):
        assert term_name is not None

        if term_name in self.terminals:
            return self.terminals[term_name]

        if self.max_terminals and len(self.terminals) >= self.max_terminals:
            raise MaxTerminalsReached(self.max_terminals)

        # Create new terminal
        self.log.info("New terminal with specified name: %s", term_name)
        directory = self.new_terminal_directory(term_name)
        record_already_started = os.path.lexists(os.path.join(directory, ASCIINEMA_RECORD_FILE))
        cmd = ASCIINEMA_COMMAND
        if record_already_started:
            cmd += ['--append']
        term = self.new_terminal(shell_command=ASCIINEMA_COMMAND, cwd=directory)
        term.term_name = term_name
        self.terminals[term_name] = term
        # Run initial action command
        action_data: dict = get_action(term_name)
        action_command = action_data.get('command')

        if action_command:
            RunTerminalCommand(action_command, term).start()
        self.start_reading(term)
        # TODO: upload_worker_data for terminals without action_command
        return term

    def start_reading(self, ptywclients):
        return super().start_reading(ptywclients)

    def on_eof(self, ptywclients):
        name = ptywclients.term_name
        upload_worker_data(name)
        return super(TermManager, self).on_eof(ptywclients)


class CustomTermSocket(TermSocket):
    def __init__(self, application, request, **kwargs):
        super().__init__(application, request, **kwargs)
        self.authenticated = False
        self.url_component = None

    def open(self, url_component=None):
        self.url_component = url_component or self.url_component
        if self.authenticated:
            return super().open(self.url_component)
        else:
            self.send_json_message(["authentication-required", ""])

    def check_origin(self, origin):
        return True

    def authenticate(self, command):
        msg_type = command[0]
        if msg_type != 'authenticate':
            self.send_json_message(["authentication-required", ""])
            return
        try:
            data = decrypt(settings.PENTEST_STUDIO_PUBLIC_KEY, command[1], src_ip=get_ip(self.request))
        except ValueError:
            data = {}
        if data and data.get('action') and data['action'] == self.action_num():
            self.send_json_message(["authenticated", ""])
            self.authenticated = True
            self.open()
        else:
            self.send_json_message(["invalid-authentication", ""])

    def action_num(self):
        last = self.request.uri.split('/')[-1]
        return int(last) if last.isdigit() else last

    def on_message(self, message):
        if not self.authenticated:
            self.authenticate(json.loads(message))
            return
        return super().on_message(message)

    def write_message(self, message, binary=False):
        return super().write_message(message, binary=binary)

    def on_pty_died(self):
        return super().on_pty_died()


def start_terminal_webserver(address: str = 'localhost', port: int = 8700):
    term_manager = TermManager(shell_command=['bash'], max_terminals=100)
    handlers = [
                (r"/_websocket/(\w+)", CustomTermSocket, {'term_manager': term_manager}),
                # (r"/xstatic/(.*)", tornado_xstatic.XStaticFileHandler)
               ]
    application = tornado.web.Application(
        handlers,
        term_manager=term_manager
    )

    application.listen(port, address)
    loop = tornado.ioloop.IOLoop.instance()
    return loop, term_manager


if __name__ == "__main__":
    start_terminal_webserver()[0].start()
