"""One shared terminal per URL endpoint
Plus a /new URL which will create a new terminal and redirect to it.
"""
from __future__ import print_function, absolute_import

import asyncio
import json
import logging
import os.path
import sys
import webbrowser
from collections import deque

import tornado.ioloop
import terminado

import tornado.web
# This demo requires tornado_xstatic and XStatic-term.js
import tornado_xstatic
from django.conf import settings
from ptyprocess import PtyProcessUnicode

from terminado import TermSocket, NamedTermManager
from terminado.management import MaxTerminalsReached, PtyWithClients

from pentest_worker.rsa import decrypt

STATIC_DIR = os.path.join(os.path.dirname(terminado.__file__), "_static")
TEMPLATE_DIR = os.path.join(os.path.dirname(__file__))
MAX_LENGTH_BUFFER = 40


AUTH_TYPES = ("none", "login")


def get_ip(request):
    x_real_ip = request.headers.get("X-Real-IP")
    return x_real_ip or request.remote_ip


class TerminalPtyWithClients(PtyWithClients):
    def __init__(self, ptyproc):
        self.ptyproc = ptyproc
        self.clients = []
        # Store the last few things read, so when a new client connects,
        # it can show e.g. the most recent prompt, rather than absolutely
        # nothing.
        self.read_buffer = deque([], maxlen=MAX_LENGTH_BUFFER)


class TerminalPageHandler(tornado.web.RequestHandler):
    """Render the /ttyX pages"""
    def get(self, term_name):
        return self.render("termpage.html", static=self.static_url,
                           xstatic=self.application.settings['xstatic_url'],
                           ws_url_path="/_websocket/"+term_name)

    def set_default_headers(self):
        self.set_header("Access-Control-Allow-Origin", "*")
        self.set_header("Access-Control-Allow-Headers", "x-requested-with")
        self.set_header('Access-Control-Allow-Methods', 'POST, GET, OPTIONS')


class NewTerminalHandler(tornado.web.RequestHandler):
    """Redirect to an unused terminal name"""
    def get(self):
        name, terminal = self.application.settings['term_manager'].new_named_terminal()
        self.redirect("/" + name, permanent=False)


class TermManager(NamedTermManager):
    def new_terminal(self, **kwargs):
        """Make a new terminal, return a :class:`PtyWithClients` instance."""
        options = self.term_settings.copy()
        options['shell_command'] = self.shell_command or ['bash']
        options.update(kwargs)
        argv = kwargs.pop('shell_command', None) or options['shell_command']
        env = self.make_term_env(**options)
        pty = PtyProcessUnicode.spawn(argv, env=env, cwd=options.get('cwd', None))
        return TerminalPtyWithClients(pty)

    def get_terminal(self, term_name, shell_command=None):
        assert term_name is not None

        if term_name in self.terminals:
            return self.terminals[term_name]

        if self.max_terminals and len(self.terminals) >= self.max_terminals:
            raise MaxTerminalsReached(self.max_terminals)

        # Create new terminal
        self.log.info("New terminal with specified name: %s", term_name)
        term = self.new_terminal(shell_command=shell_command or ['bash'])
        term.term_name = term_name
        self.terminals[term_name] = term
        self.start_reading(term)
        return term


class CustomTermSocket(TermSocket):
    def __init__(self, application, request, **kwargs):
        super().__init__(application, request, **kwargs)
        self.authenticated = False
        self.url_component = None

    def open(self, url_component=None):
        self.url_component = url_component or self.url_component
        if self.authenticated:
            return super().open(self.url_component)
        else:
            self.send_json_message(["authentication-required"])

    def check_origin(self, origin):
        return True

    def authenticate(self, command):
        msg_type = command[0]
        if msg_type != 'authenticate':
            self.send_json_message(["authentication-required"])
            return
        try:
            data = decrypt(settings.PENTEST_STUDIO_PUBLIC_KEY, command[1], src_ip=get_ip(self.request))
        except ValueError:
            data = {}
        if data and data.get('action') and data['action'] == self.action_num():
            self.send_json_message(["authenticated"])
            self.authenticated = True
            self.open()
        else:
            self.send_json_message(["invalid-authentication"])

    def action_num(self):
        last = self.request.uri.split('/')[-1]
        return int(last) if last.isdigit() else last

    def on_message(self, message):
        if not self.authenticated:
            self.authenticate(json.loads(message))
            return
        return super().on_message(message)

    def write_message(self, message, binary=False):
        return super().write_message(message, binary=binary)


def start_terminal_webserver():
    term_manager = TermManager(shell_command=['bash'], max_terminals=100)
    # Iniciar sin necesidad de acceder
    # term_manager.get_terminal('ping', ['ping', 'google.com'])

    handlers = [
                (r"/_websocket/(\w+)", CustomTermSocket,
                     {'term_manager': term_manager}),
                (r"/new/?", NewTerminalHandler),
                (r"/(\w+)/?", TerminalPageHandler),
                (r"/xstatic/(.*)", tornado_xstatic.XStaticFileHandler)
               ]
    application = tornado.web.Application(handlers, static_path=STATIC_DIR,
                              template_path=TEMPLATE_DIR,
                              xstatic_url=tornado_xstatic.url_maker('/xstatic/'),
                              term_manager=term_manager)

    application.listen(8700, 'localhost')
    loop = tornado.ioloop.IOLoop.instance()
    return loop
    # loop.start()
    # asyncio.set_event_loop(loop)
    # try:
    #     loop.start()
    # except KeyboardInterrupt:
    #     print(" Shutting down on SIGINT")
    # finally:
    #     term_manager.shutdown()
    #     loop.close()


if __name__ == "__main__":
    start_terminal_webserver().start()
