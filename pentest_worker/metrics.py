import asyncio
import json
import threading
import time
import traceback
from logging import getLogger

import psutil
import websockets
from django.conf import settings

from pentest_worker.config import get_worker_config

RESTART_TIME_WAIT = 10


logger = getLogger(__name__)


def psutil_dict(d):
    return {field: getattr(d, field) for field in d._fields}


def start_background_loop(loop: asyncio.AbstractEventLoop) -> None:
    asyncio.set_event_loop(loop)
    loop.run_forever()


def exception_handler(func):
    async def inner_function(*args, **kwargs):
        while True:
            try:
                await func(*args, **kwargs)
            except Exception:
                traceback.print_exc()
                print(f'Error on function. Waiting {RESTART_TIME_WAIT} seconds...')
                await asyncio.sleep(RESTART_TIME_WAIT)
    return inner_function


class MetricBase:
    def get_data(self):
        raise NotImplementedError

    @property
    def data(self):
        return self.get_data()


class WorkerMachineMetrics(MetricBase):
    metric_name = 'worker_machine'

    def __init__(self):
        pass

    def get_data(self):
        return {
            'cpu_usage_percent': psutil.cpu_percent(),
            'memory_usage_percent': 100 - (psutil.virtual_memory().available * 100 / psutil.virtual_memory().total),
            'root_disk_usage_percent': psutil.disk_usage('/').percent,
            'sensors_temperatures': {
                name: [psutil_dict(data) for data in datas] for name, datas in psutil.sensors_temperatures().items()
            },
            'sensors_fans': {
                name: [psutil_dict(data) for data in datas] for name, datas in psutil.sensors_fans().items()
            },
        }


class TerminalMetrics(MetricBase):
    metric_name = 'terminal'

    def __init__(self, terminal):
        self.terminal = terminal
        self.pid = terminal.ptyproc.pid

    def get_data(self):
        metric = {
            'metric_name': self.metric_name,
            'terminal_name': self.terminal.term_name,
        }
        try:
            process = psutil.Process(self.pid)
            sub_processes = process.children(recursive=True)
            return dict(metric, **{
                # It doesn't work: it always returns 0 with the first run, it requires being able to compare.
                # 'cpu_percent': process.cpu_percent() + sum([p.cpu_percent() for p in sub_processes]),
                'status': process.status(),
                'memory_percent': process.memory_percent() + sum([p.memory_percent() for p in sub_processes]),
            })
        except psutil.NoSuchProcess:
            return dict(metric, **{
                'cpu_percent': 0,
                'status': 'dead',
                'memory_percent': 0,
            })


class MonitorThread:
    daemon = True
    monitor_frequency = 2

    def __init__(self, ws_worker_url: str, term_manager):
        super(MonitorThread, self).__init__()
        self.is_active = True
        self.ws_worker_url = ws_worker_url.replace('http', 'ws')
        self.term_manager = term_manager

    def get_terms_metrics(self):
        yield {'metric_name': WorkerMachineMetrics.metric_name, 'metric_data': WorkerMachineMetrics().data}
        for term in self.term_manager.terminals.values():
            data = TerminalMetrics(term).get_data()
            yield data

    async def ws_loop(self):
        async with websockets.connect(
                self.ws_worker_url,
                extra_headers={'Authorization': 'Token {key}'.format(**get_worker_config())}) as websocket:
            while self.is_active:
                await asyncio.sleep(self.monitor_frequency)
                for metric in self.get_terms_metrics():
                    await websocket.send(json.dumps(metric))

    @exception_handler
    async def run(self) -> None:
        while True:
            try:
                await self.ws_loop()
            except websockets.ConnectionClosedError as e:
                logger.warning('Connection closed to server.')

    def start(self):
        loop = asyncio.new_event_loop()
        t = threading.Thread(target=start_background_loop, args=(loop,), daemon=True)
        t.start()
        asyncio.run_coroutine_threadsafe(self.run(), loop)

    def close(self):
        self.is_active = False
