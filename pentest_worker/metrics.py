import asyncio
import json
import threading
import time
import traceback

import psutil
import websockets
from django.conf import settings

from pentest_worker.config import get_worker_config

RESTART_TIME_WAIT = 10


def psutil_dict(d):
    return {field: getattr(d, field) for field in d._fields}


def start_background_loop(loop: asyncio.AbstractEventLoop) -> None:
    asyncio.set_event_loop(loop)
    loop.run_forever()


def exception_handler(func):
    async def inner_function(*args, **kwargs):
        while True:
            try:
                await func(*args, **kwargs)
            except Exception:
                traceback.print_exc()
                print(f'Error on function. Waiting {RESTART_TIME_WAIT} seconds...')
                await asyncio.sleep(RESTART_TIME_WAIT)
    return inner_function


class MetricBase:
    def get_data(self):
        raise NotImplementedError

    @property
    def data(self):
        return self.get_data()


class WorkerMachineMetrics(MetricBase):
    metric_name = 'worker_machine'

    def __init__(self):
        pass

    def get_data(self):
        return {
            'cpu_usage_percent': psutil.cpu_percent(),
            'memory_usage_percent': 100 - (psutil.virtual_memory().available * 100 / psutil.virtual_memory().total),
            'root_disk_usage_percent': psutil.disk_usage('/').percent,
            'sensors_temperatures': {
                name: [psutil_dict(data) for data in datas] for name, datas in psutil.sensors_temperatures().items()
            },
            'sensors_fans': {
                name: [psutil_dict(data) for data in datas] for name, datas in psutil.sensors_fans().items()
            },
        }


class TerminalMetrics(MetricBase):
    metric_name = ''

    def __init__(self, terminal):
        self.terminal = terminal

    def get_data(self):
        return {'name': self.terminal.term_name}


class MonitorThread:
    daemon = True
    monitor_frequency = 2

    def __init__(self, ws_worker_url: str):
        super(MonitorThread, self).__init__()
        self.is_active = True
        self.ws_worker_url = ws_worker_url.replace('http', 'ws')

    def get_terms_metrics(self):
        yield {'metric_name': WorkerMachineMetrics.metric_name, 'metric_data': WorkerMachineMetrics().data}
        # yield ['terms_metrics', [TerminalMetrics(term) for term in self.term_manager.terminals.values()]]

    @exception_handler
    async def run(self) -> None:
        async with websockets.connect(
                self.ws_worker_url,
                extra_headers={'Authorization': 'Token {key}'.format(**get_worker_config())}) as websocket:
            while self.is_active:
                time.sleep(self.monitor_frequency)
                for metric in self.get_terms_metrics():
                    await websocket.send(json.dumps(metric))

    def start(self):
        loop = asyncio.new_event_loop()
        t = threading.Thread(target=start_background_loop, args=(loop,), daemon=True)
        t.start()
        asyncio.run_coroutine_threadsafe(self.run(), loop)

    def close(self):
        self.is_active = False
