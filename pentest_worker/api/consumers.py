import json
from enum import Enum

from channels.auth import login
from channels.db import database_sync_to_async
from channels.generic.websocket import AsyncWebsocketConsumer
from django.contrib.auth import get_user_model
from django.core.cache import cache


class StateColor(Enum):
    GREEN = 0
    YELLOW = 1
    RED = 2


WORKER_COLOR_STATUS_EXPIRATION = 30


def dictionary_intersection(d1: dict, d2: dict):
    return dict(d1.items() & d2.items())


def get_worker_state_color(worker_machine_metric: dict) -> StateColor:
    state: int = 0
    cpu_usage_percent = worker_machine_metric.get('cpu_usage_percent', 0)
    memory_usage_percent = worker_machine_metric.get('memory_usage_percent', 0)
    root_disk_usage_percent = worker_machine_metric.get('root_disk_usage_percent', 0)
    if cpu_usage_percent >= 95:
        state = StateColor.YELLOW.value
    if memory_usage_percent >= 95 and state < StateColor.YELLOW.value:
        state = StateColor.YELLOW.value
    if memory_usage_percent >= 99 and state < StateColor.RED.value:
        state = StateColor.RED.value
    if root_disk_usage_percent >= 95 and state < StateColor.YELLOW.value:
        state = StateColor.YELLOW.value
    if root_disk_usage_percent >= 99 and state < StateColor.RED.value:
        state = StateColor.RED.value
    return StateColor(state)


class WorkerConsumer(AsyncWebsocketConsumer):
    groups = ["worker_metrics", "action_update"]
    worker = None
    filter_subscription = None

    async def connect(self):
        user = self.scope['user']
        if not user.is_authenticated:
            await self.accept()
            await self.send(text_data=json.dumps({
                'error': 'Login required',
            }))
            await self.accept()
            await self.close()
            return
        await login(self.scope, user)
        try:
            self.worker = await database_sync_to_async(lambda: user.worker)()
        except get_user_model().worker.RelatedObjectDoesNotExist:
            self.worker = None
        # self.room_name = self.scope['url_route']['kwargs']['room_name']
        # self.room_group_name = 'chat_%s' % self.room_name
        #
        if not self.worker:
            await self.channel_layer.group_add(
                'worker_metrics',
                self.channel_name
            )
        await self.accept()

    async def disconnect(self, close_code):
        # Leave room group
        if not self.worker:
            await self.channel_layer.group_discard(
                'worker_metrics',
                self.channel_name
            )

    async def worker_receive(self, text_data_json):
        if text_data_json.get('metric_name') == 'worker_machine':
            color = get_worker_state_color(text_data_json['metric_data'])
            text_data_json['metric_data']['state_color'] = color.name
            cache.set(f'worker_color_status_{self.worker.pk}', color.value, WORKER_COLOR_STATUS_EXPIRATION)
        # Send message to room group
        await self.channel_layer.group_send(
            'worker_metrics',
            {
                'worker_id': self.worker.pk,
                'type': 'chat_message',
                'message': text_data_json
            }
        )

    async def client_receive(self, text_data_json):
        if 'filter_subscription' in text_data_json:
            self.filter_subscription = text_data_json['filter_subscription']

    # Receive message from WebSocket
    async def receive(self, text_data=None, bytes_data=None):
        text_data_json = json.loads(text_data)
        if self.worker:
            await self.worker_receive(text_data_json)
        else:
            await self.client_receive(text_data_json)

    async def chat_message(self, event):
        message = event['message']
        user = self.scope['user']
        if not user.is_authenticated or (
                self.filter_subscription and
                dictionary_intersection(self.filter_subscription, message) != self.filter_subscription):
            return
        # Send message to WebSocket
        await self.send(text_data=json.dumps({
            'worker_id': event['worker_id'],
            'message': message,
        }))
