import codecs
import glob
import os
import re
import tarfile
from itertools import chain
from typing import Type, Callable, Optional

import toml
from asciinema import asciicast
from asciinema.commands.cat import CatCommand
from django.conf import settings
from django.db.models import F, Q
from django.http import StreamingHttpResponse, Http404
from django.utils.functional import cached_property
from django.views.static import serve
from django_filters.rest_framework import DjangoFilterBackend
from rest_framework import viewsets, filters, mixins, renderers, serializers
from rest_framework.decorators import action
from rest_framework.exceptions import ValidationError
from rest_framework.parsers import JSONParser
from rest_framework.renderers import JSONRenderer, BrowsableAPIRenderer
from rest_framework import parsers
from rest_framework.response import Response
from rest_framework.serializers import Serializer

from pentest_project.exceptions import ItemDoesNotExist
from pentest_project.plugins import PluginCollections, Plugins, PluginShortcuts, Plugin
from pentest_studio.api import BaseViewSetMixIn, StandardResultsSetPagination
from pentest_worker.models import Worker
from pentest_project.api.filters import ActionFilter
from pentest_project.api.serializers import ProjectSerializer, ActionSerializer, DetailProjectSerializer, \
    DetailActionSerializer, PluginSetupSerializer, PluginSerializer, PluginShortcutArgSerializer, \
    PluginShortcutEnvSerializer, PluginShortcutSerializer, RenderShortcutSerializer, PluginCollectionSerializer
from pentest_project.models import Project, Action


def serve_file(request, filepath):
    return serve(request, os.path.basename(filepath), os.path.dirname(filepath))


def asciinema_cat(file):
    with asciicast.open_from_url(file) as a:
        for t, _type, text in a.stdout_events():
            yield text


def filter_toml_file(file_id):
    def filter_file(file):
        return re.match('{}\.plugin\.to?ml$'.format(re.escape(file_id)), file, re.IGNORECASE)
    return filter_file


class FilesQuerySet:
    def __init__(self, directory: str, read_file: Callable, filter_callable: Optional[Callable] = None):
        self.directory = directory
        self.read_file = read_file
        self.filter_callable = filter_callable

    @cached_property
    def file_names(self):
        file_names = os.listdir(self.directory)
        if self.filter_callable is not None:
            file_names = list(filter(self.filter_callable, file_names))
        return file_names

    def __iter__(self):
        return map(self.read_file, self.file_names)

    def __len__(self):
        return len(self.file_names)

    def __getitem__(self, item):
        if not isinstance(item, slice):
            raise ValueError(f'Unsupported slice type: {item}')
        return map(self.read_file, self.file_names[item])


class PlainTextRenderer(renderers.BaseRenderer):
    media_type = 'text/plain'
    format = 'text'

    def render(self, data, media_type=None, renderer_context=None):
        return data


class PlainTextParser(parsers.FileUploadParser):
    media_type = 'text/plain'
    # TODO: tomar el nombre del fichero si es la creación del mismo

    def parse(self, stream, media_type=None, parser_context=None):
        """
        Given a stream to read from, return the parsed representation.
        Should return parsed data, or a `DataAndFiles` object consisting of the
        parsed data and files.
        """
        encoding = parser_context.get('encoding', settings.DEFAULT_CHARSET)
        decoded_stream = codecs.getreader(encoding)(stream)
        return decoded_stream


class TomlParser(parsers.FileUploadParser):
    media_type = 'application/toml'
    # TODO: tomar el nombre del fichero si es la creación del mismo

    def parse(self, stream, media_type=None, parser_context=None):
        """
        Given a stream to read from, return the parsed representation.
        Should return parsed data, or a `DataAndFiles` object consisting of the
        parsed data and files.
        """
        encoding = parser_context.get('encoding', settings.DEFAULT_CHARSET)
        decoded_stream = codecs.getreader(encoding)(stream)
        raw_body = decoded_stream.read()
        request = parser_context.get('request')
        setattr(request, 'raw_body', raw_body)
        filename = self.get_filename(stream, media_type, parser_context)
        if filename and (not filename.endswith('.toml') and not filename.endswith('.tml')):
            filename = f'{filename}.toml'
        setattr(request, 'filename', filename)
        return toml.loads(raw_body)


class ProjectViewSet(BaseViewSetMixIn, viewsets.ModelViewSet):
    """
    """
    queryset = Project.objects.all().order_by('-pk')
    serializer_class = ProjectSerializer
    filter_backends = (filters.OrderingFilter, filters.SearchFilter, DjangoFilterBackend)
    search_fields = ('name',)
    filter_fields = ('parent', 'created_at', 'updated_at')
    ordering_fields = filter_fields
    detail_serializer_class = DetailProjectSerializer


class ActionViewSet(BaseViewSetMixIn, viewsets.ModelViewSet):
    """
    """
    queryset = Action.objects.order_by('-pk')
    serializer_class = ActionSerializer
    filter_backends = (filters.OrderingFilter, filters.SearchFilter, DjangoFilterBackend)
    search_fields = ('name',)
    filterset_class = ActionFilter
    ordering_fields = ('parent', 'parent', 'created_at', 'updated_at')
    detail_serializer_class = DetailActionSerializer
    pagination_class = StandardResultsSetPagination

    def get_queryset(self):
        queryset = super(ActionViewSet, self).get_queryset()
        if self.action == 'grouped':
            # Filtrar por (plugin + is_last) or not plugin
            queryset = queryset.filter(Q(plugin='') | Q(is_last=True))
        return queryset

    @action(methods=['put'], detail=True)
    def worker_upload(self, request, pk):
        file_obj = request.data['file']
        instance: Action = self.get_object()
        if not instance.project:
            return Response(status=204)
        directory = os.path.dirname(instance.get_data_directory())
        os.makedirs(directory, exist_ok=True)
        t = tarfile.open(fileobj=file_obj.file)
        t.extractall(directory)
        return_code = instance.get_return_code()
        if return_code is None:
            instance.status = 'FINISHED'
        else:
            instance.status = 'SUCCESS' if return_code == 0 else 'ERROR'
        instance.save()
        return Response(status=204)

    @action(methods=['get'], detail=True, url_path='asciinema.cast')
    def download_cast(self, request, pk):
        instance: Action = self.get_object()
        return serve_file(request, instance.get_terminal_path())

    @action(methods=['get'], detail=True)
    def terminal_output(self, request, pk):
        instance: Action = self.get_object()
        file: str = instance.get_terminal_path()
        if not os.path.lexists(file) or not os.path.getsize(file):
            raise Http404
        return StreamingHttpResponse(asciinema_cat(file))

    @action(methods=['post'], detail=True)
    def block_task(self, request, pk):
        instance: Action = self.get_object()
        try:
            worker = Worker.objects.get(user=request.user)
        except Worker.DoesNotExist:
            raise ValidationError('User {} is not a worker'.format(request.user))
        instance.block_task(worker)
        instance.save()
        return self.retrieve(request, pk)

    @action(methods=['get'], detail=False)
    def grouped(self, request, *args, **kwargs):
        return self.list(request, *args, **kwargs)


class FileTomlViewSet(mixins.ListModelMixin, mixins.RetrieveModelMixin,
                      viewsets.GenericViewSet, viewsets.ViewSet):
    pagination_class = StandardResultsSetPagination
    serializer_class: Type[Serializer] = None
    parser_classes = (TomlParser,)

    def get_renderers(self):
        if self.action == 'text':
            return [PlainTextRenderer()]
        else:
            return super(FileTomlViewSet, self).get_renderers()

    def get_queryset(self):
        raise NotImplementedError

    def get_object(self):
        lookup_url_kwarg = self.lookup_url_kwarg or self.lookup_field
        try:
            return self.get_queryset().from_name(self.kwargs[lookup_url_kwarg])
        except ItemDoesNotExist:
            raise Http404

    def update(self, request, *args, **kwargs):
        return super(FileTomlViewSet, self).update(request, *args, **kwargs)

    @action(detail=True, methods=['get'])
    def text(self, request, *args, **kwargs):
        obj = self.get_object()
        return Response(obj.text)


class PluginViewSet(mixins.UpdateModelMixin, mixins.CreateModelMixin, mixins.DestroyModelMixin, FileTomlViewSet):
    serializer_class = PluginSerializer
    parser_classes = (TomlParser, JSONParser)

    def get_serializer_class(self):
        if self.action == 'install':
            return serializers.Serializer
        else:
            return super(PluginViewSet, self).get_serializer_class()

    def get_queryset(self):
        return Plugins()

    @action(detail=True, methods=['post'])
    def install(self, request, *args, **kwargs):
        obj: Plugin = self.get_object()
        actions = Worker.objects.active().run_command(f'Installing the {obj.name} plugin', obj.setup['install'])
        serializer = ActionSerializer(many=True, instance=actions, context=self.get_serializer_context())
        return Response(serializer.data)


class PluginShortcutViewSet(FileTomlViewSet):
    serializer_class = PluginShortcutSerializer
    lookup_value_regex = '[a-zA-Z0-9.\-]+'
    parser_classes = (JSONParser,)
    renderer_classes = (JSONRenderer, BrowsableAPIRenderer, PlainTextRenderer)

    def get_queryset(self):
        return PluginShortcuts()

    @action(methods=['post'], detail=True)
    def render_command(self, request, pk=None):
        obj = self.get_object()
        serializer = RenderShortcutSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        return Response(serializer.render(obj))


class PluginCollectionViewSet(mixins.UpdateModelMixin, mixins.CreateModelMixin, mixins.DestroyModelMixin,
                              FileTomlViewSet):
    serializer_class = PluginCollectionSerializer

    def get_queryset(self):
        return PluginCollections()
