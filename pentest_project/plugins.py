import os.path
import re
import shutil
from typing import TypedDict, List, Iterator, TYPE_CHECKING, Optional

import toml
from django.conf import settings
from django.utils.functional import cached_property
from jinja2 import Template

from pentest_project.exceptions import PluginDoesNotExist, PluginShortcutDoesNotExist, ItemDoesNotExist

if TYPE_CHECKING:
    from pentest_project.models import Project


def render_shortcut_command(command: str, project: 'Project', env_data: Optional[dict] = None) -> str:
    env_data = env_data or {}
    template = Template(command)
    env = {'url': project.url}
    env.update(project.data or {})
    env.update(env_data)
    return template.render(**env)


class PluginSetupDict(TypedDict):
    test: str
    install: str


class PluginShortcutArgDict(TypedDict):
    id: str
    type: str


class PluginShortcutEnvDict(TypedDict):
    key: str
    value: str


class PluginShortcutDict(TypedDict):
    id: str
    name: str
    help: str
    command: str
    args: List[PluginShortcutArgDict]
    envs: List[PluginShortcutEnvDict]


class PluginDict(TypedDict):
    name: str
    description: str
    setup: PluginSetupDict
    shortcuts: List[PluginShortcutDict]


class PluginCollectionDict(TypedDict):
    name: str
    plugin_shortcuts: List[str]
    type: str
    start: str  # auto, manual


class TomlFile:
    directory: str

    def __init__(self, path: str):
        self.path = path

    def read(self) -> dict:
        with open(self.path, 'r') as f:
            return toml.load(f)

    def write(self, data: str):
        with open(self.path, 'w') as f:
            f.write(data)

    @cached_property
    def data(self) -> dict:
        return self.read()

    @cached_property
    def text(self) -> str:
        with open(self.path, 'r') as f:
            return f.read()

    @property
    def filename(self):
        return os.path.basename(self.path)

    def rename(self, new_name: str):
        new_path = os.path.join(os.path.dirname(self.path), new_name)
        shutil.move(self.path, new_path)
        self.path = new_path

    def delete(self):
        os.remove(self.path)


class PluginShortcut:
    def __init__(self, data: PluginShortcutDict, plugin: 'Plugin'):
        self.data = data
        self.plugin = plugin

    @property
    def pk(self):
        return self.full_id

    @property
    def id(self):
        return self.data['id']

    @property
    def plugin_id(self):
        return self.plugin.id

    @property
    def full_id(self):
        return f'{self.plugin.id}.{self.id}'

    @property
    def name(self):
        return self.data['name']

    @property
    def help(self):
        return self.data['help']

    @property
    def command(self):
        return self.data['command']

    @property
    def args(self):
        return self.data['args']

    @property
    def envs(self):
        return self.data['envs']


class Plugin(TomlFile):
    @property
    def pk(self):
        return self.id

    @cached_property
    def data(self) -> PluginDict:
        return super(Plugin, self).data

    @property
    def id(self):
        return self.filename.split('.')[0]

    @property
    def name(self):
        return self.data['name']

    @property
    def description(self):
        return self.data['description']

    @property
    def setup(self):
        return self.data['setup']

    @property
    def shortcuts(self) -> List[PluginShortcut]:
        return list(map(lambda x: PluginShortcut(x, self), self.data['shortcuts']))

    def shortcut_from_id(self, shortcut_id: str):
        try:
            return next(filter(lambda x: x.id == shortcut_id, self.shortcuts))
        except StopIteration:
            raise PluginShortcutDoesNotExist(f'Plugin shortcut id {shortcut_id} does not exist.')

    @classmethod
    def from_name(cls, plugin_name: str):
        paths = [
            os.path.join(settings.PLUGIN_DIRECTORY, f'{plugin_name}.plugin.toml'),
            os.path.join(settings.PLUGIN_DIRECTORY, f'{plugin_name}.plugin.tml'),
        ]
        for path in paths:
            if os.path.lexists(path):
                return Plugin(path)
        raise PluginDoesNotExist(f'Plugin {plugin_name} does not exists.')


class PluginCollection(TomlFile):

    @property
    def pk(self):
        return self.id

    @property
    def id(self):
        return self.filename.split('.')[0]

    @property
    def name(self):
        return self.data['name']

    @property
    def plugin_shortcuts(self) -> Iterator[PluginShortcut]:
        plugins = {}
        plugin_shortcuts = self.data['plugin_shortcuts']
        for plugin_shortcut in plugin_shortcuts:
            plugin_name, shortcut_name = plugin_shortcut.split('.', 1)
            if plugin_name not in plugins:
                plugins[plugin_name] = Plugin.from_name(plugin_name)
            yield plugins[plugin_name].shortcut_from_id(shortcut_name)
        return self.data['plugin_shortcuts']

    @property
    def type(self):
        return self.data['type']

    @property
    def start(self):
        return self.data['start']

    @cached_property
    def data(self) -> PluginCollectionDict:
        return super(PluginCollection, self).data


class PluginItemsBase:
    directory = settings.PLUGIN_DIRECTORY
    type: str = None
    pattern = None
    item_cls = None

    def __init__(self):
        pass

    @classmethod
    def from_name(cls, name: str):
        paths = [
            os.path.join(cls.directory, f'{name}.{cls.type}.toml'),
            os.path.join(cls.directory, f'{name}.{cls.type}.tml'),
        ]
        for path in paths:
            if os.path.lexists(path):
                return cls.item_cls(path)
        raise ItemDoesNotExist(f'Item {name} does not exist.')

    @cached_property
    def all(self):
        return list(iter(self))

    def __len__(self):
        return len(self.all)

    def __getitem__(self, item):
        return list(self.all)[item]

    def __iter__(self) -> Iterator:
        files = filter(lambda name: self.pattern.match(name), os.listdir(self.directory))
        return map(lambda name: self.item_cls(os.path.join(self.directory, name)), files)


class Plugins(PluginItemsBase):
    pattern = re.compile('^.+\.plugin\.to?ml$')
    type = 'plugin'
    item_cls = Plugin


class PluginShortcuts(PluginItemsBase):
    pattern = re.compile('^.+\.plugin\.to?ml$')
    type = 'plugin'
    item_cls = PluginShortcut

    @classmethod
    def from_name(cls, name: str):
        if '.' not in name:
            raise ItemDoesNotExist
        plugin_name, shortcut_id = name.split('.', 1)
        plugin = Plugins().from_name(plugin_name)
        return plugin.shortcut_from_id(shortcut_id)

    def __iter__(self):
        plugins = Plugins()
        for plugin in plugins:
            yield from plugin.shortcuts


class PluginCollections(PluginItemsBase):
    pattern = re.compile('^.+\.collection\.to?ml$')
    type = 'collection'
    item_cls = PluginCollection

    def filter_by_type(self, type_name: str) -> Iterator[PluginCollection]:
        return filter(lambda collection: collection.type == type_name, self)

    def plugin_shortcuts_by_type(self, type_name: str) -> Iterator[PluginShortcut]:
        for collection in self.filter_by_type(type_name):
            yield from collection.plugin_shortcuts
