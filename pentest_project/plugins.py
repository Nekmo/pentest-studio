import os.path
import re
from typing import TypedDict, List, Iterator, TYPE_CHECKING, Optional

import toml
from django.conf import settings
from django.utils.functional import cached_property
from jinja2 import Template

from pentest_project.exceptions import PluginDoesNotExist, PluginShortcutDoesNotExist, PluginCollectionDoesNotExist

if TYPE_CHECKING:
    from pentest_project.models import Project


def render_shortcut_command(command: str, project: 'Project', env_data: Optional[dict] = None) -> str:
    env_data = env_data or {}
    template = Template(command)
    env = {'url': project.url}
    env.update(project.data or {})
    env.update(env_data)
    return template.render(**env)


class PluginSetupDict(TypedDict):
    test: str
    install: str


class PluginShortcutArgDict(TypedDict):
    id: str
    type: str


class PluginShortcutEnvDict(TypedDict):
    key: str
    value: str


class PluginShortcutDict(TypedDict):
    id: str
    name: str
    help: str
    command: str
    args: List[PluginShortcutArgDict]
    envs: List[PluginShortcutEnvDict]


class PluginDict(TypedDict):
    name: str
    description: str
    setup: PluginSetupDict
    shortcuts: List[PluginShortcutDict]


class PluginCollectionDict(TypedDict):
    name: str
    plugin_shortcuts: List[str]
    type: str
    start: str  # auto, manual


class TomlFile:
    def __init__(self, path: str):
        self.path = path

    def read(self) -> dict:
        with open(self.path, 'r') as f:
            return toml.load(f)

    @cached_property
    def data(self) -> dict:
        return self.read()

    @cached_property
    def text(self) -> str:
        with open(self.path, 'r') as f:
            return f.read()

    @property
    def filename(self):
        return os.path.basename(self.path)


class PluginShortcut:
    def __init__(self, data: PluginShortcutDict, plugin: 'Plugin'):
        self.data = data
        self.plugin = plugin

    @property
    def id(self):
        return self.data['id']

    @property
    def full_id(self):
        return f'{self.plugin.id}.{self.id}'

    @property
    def name(self):
        return self.data['name']

    @property
    def help(self):
        return self.data['help']

    @property
    def command(self):
        return self.data['command']


class Plugin(TomlFile):
    @cached_property
    def data(self) -> PluginDict:
        return super(Plugin, self).data

    @property
    def id(self):
        return self.filename.split('.')[0]

    @property
    def shortcuts(self) -> List[PluginShortcut]:
        return list(map(lambda x: PluginShortcut(x, self), self.data['shortcuts']))

    def shortcut_from_id(self, shortcut_id: str):
        try:
            return next(filter(lambda x: x.id == shortcut_id, self.shortcuts))
        except StopIteration:
            raise PluginShortcutDoesNotExist(f'Plugin shortcut id {shortcut_id} does not exist.')

    @classmethod
    def from_name(cls, plugin_name: str):
        paths = [
            os.path.join(settings.PLUGIN_DIRECTORY, f'{plugin_name}.plugin.toml'),
            os.path.join(settings.PLUGIN_DIRECTORY, f'{plugin_name}.plugin.tml'),
        ]
        for path in paths:
            if os.path.lexists(path):
                return Plugin(path)
        raise PluginDoesNotExist(f'Plugin {plugin_name} does not exists.')


class PluginCollection(TomlFile):

    @property
    def pk(self):
        return self.id

    @property
    def id(self):
        return self.filename.split('.')[0]

    @property
    def name(self):
        return self.data['name']

    @property
    def plugin_shortcuts(self) -> Iterator[PluginShortcut]:
        plugins = {}
        plugin_shortcuts = self.data['plugin_shortcuts']
        for plugin_shortcut in plugin_shortcuts:
            plugin_name, shortcut_name = plugin_shortcut.split('.', 1)
            if plugin_name not in plugins:
                plugins[plugin_name] = Plugin.from_name(plugin_name)
            yield plugins[plugin_name].shortcut_from_id(shortcut_name)
        return self.data['plugin_shortcuts']

    @property
    def type(self):
        return self.data['type']

    @property
    def start(self):
        return self.data['start']

    @cached_property
    def data(self) -> PluginCollectionDict:
        return super(PluginCollection, self).data


class PluginCollections:
    directory = settings.PLUGIN_DIRECTORY
    pattern = re.compile('^.+\.collection\.to?ml$')

    def __init__(self):
        pass

    @classmethod
    def from_name(cls, collection_name: str):
        paths = [
            os.path.join(settings.PLUGIN_DIRECTORY, f'{collection_name}.collection.toml'),
            os.path.join(settings.PLUGIN_DIRECTORY, f'{collection_name}.collection.tml'),
        ]
        for path in paths:
            if os.path.lexists(path):
                return PluginCollection(path)
        raise PluginCollectionDoesNotExist(f'Plugin collection {collection_name} does not exist.')

    def filter_by_type(self, type_name: str) -> Iterator[PluginCollection]:
        return filter(lambda collection: collection.type == type_name, self)

    def plugin_shortcuts_by_type(self, type_name: str) -> Iterator[PluginShortcut]:
        for collection in self.filter_by_type(type_name):
            yield from collection.plugin_shortcuts

    def __iter__(self) -> Iterator[PluginCollection]:
        files = filter(lambda name: self.pattern.match(name), os.listdir(self.directory))
        return map(lambda name: PluginCollection(os.path.join(self.directory, name)), files)
