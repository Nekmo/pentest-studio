import glob
import os
import re
import tarfile
from itertools import chain
from typing import Type, Callable

import toml
from asciinema import asciicast
from asciinema.commands.cat import CatCommand
from django.conf import settings
from django.http import StreamingHttpResponse, Http404
from django.utils.functional import cached_property
from django.views.static import serve
from django_filters.rest_framework import DjangoFilterBackend
from rest_framework import viewsets, filters, mixins, renderers
from rest_framework.decorators import action
from rest_framework.exceptions import ValidationError
from rest_framework.renderers import JSONRenderer, BrowsableAPIRenderer
from rest_framework.response import Response
from rest_framework.serializers import Serializer

from pentest_studio.api import BaseViewSetMixIn, StandardResultsSetPagination
from pentest_worker.models import Server
from projects.api.filters import ActionFilter
from projects.api.serializers import ProjectSerializer, ActionSerializer, DetailProjectSerializer, \
    DetailActionSerializer, PluginSetupSerializer, PluginSerializer, PluginShortcutArgSerializer, \
    PluginShortcutEnvSerializer, PluginShortcutSerializer, RenderShortcutSerializer
from projects.models import Project, Action


def serve_file(request, filepath):
    return serve(request, os.path.basename(filepath), os.path.dirname(filepath))


def asciinema_cat(file):
    with asciicast.open_from_url(file) as a:
        for t, _type, text in a.stdout_events():
            yield text


def filter_toml_file(file_id):
    def filter_file(file):
        return re.match('{}\.(?:plugin\.|)to?ml$'.format(re.escape(file_id)), file, re.IGNORECASE)
    return filter_file


class FilesQuerySet:
    def __init__(self, directory: str, read_file: Callable):
        self.directory = directory
        self.read_file = read_file

    @cached_property
    def file_names(self):
        return os.listdir(self.directory)

    def __iter__(self):
        return map(self.read_file, self.file_names)

    def __len__(self):
        return len(self.file_names)

    def __getitem__(self, item):
        if not isinstance(item, slice):
            raise ValueError(f'Unsupported slice type: {item}')
        return map(self.read_file, self.file_names[item])


class PlainTextRenderer(renderers.BaseRenderer):
    media_type = 'text/plain'
    format = 'text'

    def render(self, data, media_type=None, renderer_context=None):
        return data


class ProjectViewSet(BaseViewSetMixIn, viewsets.ModelViewSet):
    """
    """
    queryset = Project.objects.all()
    serializer_class = ProjectSerializer
    filter_backends = (filters.OrderingFilter, filters.SearchFilter, DjangoFilterBackend)
    search_fields = ('name',)
    filter_fields = ('parent', 'created_at', 'updated_at')
    ordering_fields = filter_fields
    detail_serializer_class = DetailProjectSerializer


class ActionViewSet(BaseViewSetMixIn, viewsets.ModelViewSet):
    """
    """
    queryset = Action.objects.all()
    serializer_class = ActionSerializer
    filter_backends = (filters.OrderingFilter, filters.SearchFilter, DjangoFilterBackend)
    search_fields = ('name',)
    filterset_class = ActionFilter
    ordering_fields = ('parent', 'parent', 'created_at', 'updated_at')
    detail_serializer_class = DetailActionSerializer
    pagination_class = StandardResultsSetPagination

    @action(methods=['put'], detail=True)
    def worker_upload(self, request, pk):
        file_obj = request.data['file']
        instance: Action = self.get_object()
        directory = os.path.dirname(instance.get_data_directory())
        os.makedirs(directory, exist_ok=True)
        t = tarfile.open(fileobj=file_obj.file)
        t.extractall(directory)
        return_code = instance.get_return_code()
        if return_code is None:
            instance.status = 'FINISHED'
        else:
            instance.status = 'SUCCESS' if return_code == 0 else 'ERROR'
        instance.save()
        return Response(status=204)

    @action(methods=['get'], detail=True, url_path='asciinema.cast')
    def download_cast(self, request, pk):
        instance: Action = self.get_object()
        return serve_file(request, instance.get_terminal_path())

    @action(methods=['get'], detail=True)
    def terminal_output(self, request, pk):
        instance: Action = self.get_object()
        file: str = instance.get_terminal_path()
        if not os.path.lexists(file) or not os.path.getsize(file):
            raise Http404
        return StreamingHttpResponse(asciinema_cat(file))

    @action(methods=['post'], detail=True)
    def block_task(self, request, pk):
        instance: Action = self.get_object()
        try:
            server = Server.objects.get(user=request.user)
        except Server.DoesNotExist:
            raise ValidationError('User {} is not a server'.format(request.user))
        instance.block_task(server)
        instance.save()
        return self.retrieve(request, pk)


class FileTomlViewSet(mixins.ListModelMixin, mixins.RetrieveModelMixin,
                      viewsets.GenericViewSet, viewsets.ViewSet):
    serializer_class: Type[Serializer] = None

    def get_directory_path(self) -> str:
        raise NotImplementedError

    def get_file(self, pk):
        return toml.load(open(os.path.join(self.get_directory_path(), pk), 'r'))

    def list_files(self):
        return os.listdir(self.get_directory_path())

    def get_queryset(self):
        return FilesQuerySet(self.get_directory_path(), self.get_file)
        # return map(self.get_file, self.list_files())

    def get_file_id(self):
        lookup_url_kwarg = self.lookup_url_kwarg or self.lookup_field
        return self.kwargs[lookup_url_kwarg]

    def get_object(self):
        file_id = self.get_file_id()
        try:
            file = next(filter(filter_toml_file(file_id),
                               self.list_files()))
        except StopIteration:
            raise Http404
        return self.get_file(file)


class PluginViewSet(FileTomlViewSet):
    pagination_class = StandardResultsSetPagination
    serializer_class = PluginSerializer

    def get_directory_path(self):
        return settings.PLUGIN_DIRECTORY

    def get_file(self, pk):
        obj = super().get_file(pk)
        obj = dict(id=pk, **obj)
        obj['shortcuts'] = [dict(plugin_id=pk.split('.')[0], shortcut_id=shortcut['id'],
                                 _id='.'.join([pk.split('.')[0], shortcut['id']]),
                                 **shortcut)
                            for shortcut in obj['shortcuts']]
        return obj


class PluginSetupViewSet(PluginViewSet):
    serializer_class = PluginSetupSerializer
    pagination_class = None


class PluginShortcutArgViewSet(PluginViewSet):
    serializer_class = PluginShortcutArgSerializer
    pagination_class = None


class PluginShortcutEnvViewSet(PluginViewSet):
    serializer_class = PluginShortcutEnvSerializer
    pagination_class = None


class PluginShortcutViewSet(PluginViewSet):
    serializer_class = PluginShortcutSerializer
    lookup_value_regex = '[a-zA-Z0-9.\-]+'
    renderer_classes = (JSONRenderer, BrowsableAPIRenderer, PlainTextRenderer)
    pagination_class = None

    def get_file(self, pk):
        data = super().get_file(pk)
        return map(lambda x: dict(id=(pk, x.pop('id')), **x), data['shortcuts'])

    def get_object(self):
        lookup_url_kwarg = self.lookup_url_kwarg or self.lookup_field
        id_ = self.kwargs[lookup_url_kwarg].split('.')[1]
        try:
            obj = next(filter(lambda x: x['id'][1] == id_, super().get_object()))
        except StopIteration:
            raise Http404
        return obj

    def get_queryset(self):
        plugin_id = self.request.GET.get('plugin_id')
        if plugin_id:
            datas = map(self.get_file, filter(filter_toml_file(plugin_id),
                                              self.list_files()))
        else:
            datas = super().get_queryset()
        return chain(*datas)

    def get_file_id(self):
        file_id = super().get_file_id()
        return file_id.split('.')[0]

    @action(methods=['post'], detail=True)
    def render_command(self, request, pk=None):
        obj = self.get_object()
        serializer = RenderShortcutSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        return Response(serializer.render(obj))
        # serializer = RenderShortcutSerializer(data=request.data)
        # serializer.is_valid(raise_exception=True)
        # serializer.save()
        # headers = self.get_success_headers(serializer.data)
        # return Response(serializer.data, status=status.HTTP_201_CREATED, headers=headers)
